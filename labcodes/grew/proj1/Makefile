PROJ		:= ucore
EMPTY		:=
SPACE		:= $(EMPTY) $(EMPTY)
SLASH		:= /

V			:= @

#need llvm/cang-3.5+
#USELLVM := -1

# try to infer the correct GCCPREFIX
# The result is `GCCPREFIX := `
ifndef GCCPREFIX
GCCPREFIX := $(shell if i386-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
	then echo 'i386-elf-'; \
	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
	then echo ''; \
	else echo "***" 1>&2; \
	echo "*** Error: Couldn't find an i386-elf version of GCC/binutils." 1>&2; \
	echo "*** Is the directory with i386-elf-gcc in your PATH?" 1>&2; \
	echo "*** If your i386-elf toolchain is installed with a command" 1>&2; \
	echo "*** prefix other than 'i386-elf-', set your GCCPREFIX" 1>&2; \
	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
	echo "*** To turn off this error, run 'gmake GCCPREFIX= ...'." 1>&2; \
	echo "***" 1>&2; exit 1; fi)
endif

# try to infer the correct QEMU
# The result is `QEMU := qemu-system-i386`
ifndef QEMU
QEMU := $(shell if which qemu-system-i386 > /dev/null; \
	then echo 'qemu-system-i386'; exit; \
	elif which i386-elf-qemu > /dev/null; \
	then echo 'i386-elf-qemu'; exit; \
	elif which qemu > /dev/null; \
	then echo 'qemu'; exit; \
	else \
	echo "***" 1>&2; \
	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
	echo "***" 1>&2; exit 1; fi)
endif

# eliminate default suffix rules
# 默认的后缀列表是:.out, .a, .ln, .o, .c, .cc, .C, .p,
# .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .h, 
# .info, .dvi, .tex, .texinfo, .texi,
# .txinfo, .w, .ch .web, .sh, .elc, .el
.SUFFIXES: .c .S .h

# delete target files if there is an error(or make is interrupted)
.DELETE_ON_ERROR:

# define complier and flags

HOSTCC		:= gcc
HOSTCFLAGS	:= -g -Wall -O2

GDB			:= $(GCCPREFIX)gdb

CC 			:= $(GCCPREFIX)gcc
CFLAGS		:= -fno-builtin -Wall -ggdb -m32 -nostdinc
CFLAGS		+= $(shell $(CC) -fno-stack-protector -E -x c /dev/null > dev/null 2 >&1 && echo -fno-stack-protector)
CTYPE		:= c S

LD			:= $(GCCPREFIX)ld 		
LDFLAGS		:= -m $(shell $(LD) -V | grep elf_i386 2 > /dev/null)

OBJCOPY		:= $(GCCPREFIX)objcopy
OBJDUMP 	:= $(GCCPREFIX)objdump

COPY		:= cp
MKDIR		:= mkdir -p
MV 			:= mv
RM 			:= rm -f

OBJDIR 		:= obj
BINDIR		:= bin

ALLOBJS 	:=
ALLDEPS		:= 
TARGETS		:=

include tools/function.mk

listf_cc = $(call listf, $(1), $(CTYPE))

# for cc
add_files_cc = $(call add_files, $(1), $(CC), $(CFLAGS) $(3), $(2), $(4))
create_target_cc = $(call )

# for hostcc
add_files_host = $(call add_files, $(1), $(HOSTCC), $(HOSTCFLAGS), $(2), $(3))
create_target_host = $(call create_target, $(1), $(2), $(3), $(HOSTCC), $(HOSTCFLAGS))

cgtype = $(patsubst %.$(2), %.$(3), $(1))
objfile = $(call toobj,$(1))
asmfile = $(call cgtype, $(call toobj, $(1), o, asm))
outfile = $(call cgtype, $(call toobj, $(1), o, out))
symfile = $(call cgtype, $(call toobj, $(1), o, sym))

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

INCLUDE += libs/

CFLAGS += $(addprefix -I,$(INCLUDE))

# -------------------------------------------------------------------

#create bootblock
bootfiles = $(call listf_cc, boot)
$(foreach f, $(bootfiles),$(call cc_compile, $(f), $(CC), $(CFLAGS) -Os -nostdinc))

bootblock = $(call totarget, bootblock)

$(bootblock): $(call toobj, boot/bootasm.S) $(call toobj, $(bootfiles)) | $(call totarget, sign)
	@echo +ld $@
	$(V)$(LD)$(LDFLAGS) -N -e start -Ttext 0x7c00 $^ -o $(call toobj,bootblock)
	@$(OBJDUMP) -S $(call objfile, bootblock) > $(call asmfile, bootblock)
	@$(OBJCOPY) -S -O binary $(call objfile, bootblock) $(call outfile, bootblock)
	@$(call totarget, sign) $(call outfile, bootblock) $(bootblock)

$(call create_target, bootblock)


# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

# create 'sign' tools
$(call add_files_host, tools/sign.c, sign, sign)
$(call create_target_host, sign, sign)

# --------------------------------------------------------------------

# create ucore.img

UCOREIMG	:= $(call totarget, ucore.img)

$(UCOREIMG): $(call totarget, bootblock)
	$(V)dd if=/dev/zero of=$@ count=10000
	$(V)dd if=$< of=$@ conv=notrunc

$(call create_target, ucore.img)

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


$(call finish_all)

ifneq ($(MAKECMDGOALS), clean)
-include $(ALLDEPS)
endif

TARGETS: $(TARGETS)

.DEFAULT_GOAL := TARGETS

.PHONY: qemu qemu-nox debug debug-nox

qemu: $(UCOREIMG)
	$(V)$(QEMU) -parallel stdio -hda $< -serial null

qemu-nox: $(UCOREIMG)
	$(V)$(QEMU) -serial mon:stdio -hda $< -nographic

TERMINAL := gnome-terminal

debug: $(UCOREIMG)
	$(V)$(QEMU) -S -s -parallel stdio -hda $< serial null &
	$(V)sleep 2
	$(V)$(TERMINAL) -e "$(GDB) -q -x tools/gdbinit"

debug-nox: $(UCOREIMG)
	$(V)$(QEMU) -S -s -serial mon: stdio -ha $< -nographic &
	$(V)sleep 2
	$(V)$(TERMINAL) -e "$(GDB) -q -x tools/gdbinit"

.PHONY: clean

clean:
	-$(RM) -r $(OBJDIR) $(BINDIR)


